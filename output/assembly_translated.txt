tmp(0)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com o valor 0
tmp(1)	 := STA & "111111110"; -- STA @510   Limpa KEY1
tmp(2)	 := STA & "111111111"; -- STA @511   Limpa KEY0
tmp(3)	 := STA & "111111101"; -- STA @509   Limpa KEY_RESET
tmp(4)	 := STA & "100100000"; -- STA @288   Armazena o valor do acumulador em HEX0
tmp(5)	 := STA & "100100001"; -- STA @289   Armazena o valor do acumulador em HEX1
tmp(6)	 := STA & "100100010"; -- STA @290   Armazena o valor do acumulador em HEX2
tmp(7)	 := STA & "100100011"; -- STA @291   Armazena o valor do acumulador em HEX3
tmp(8)	 := STA & "100100100"; -- STA @292   Armazena o valor do acumulador em HEX4
tmp(9)	 := STA & "100100101"; -- STA @293   Armazena o valor do acumulador em HEX5
tmp(10)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com o valor 0
tmp(11)	 := STA & "100000000"; -- STA @256   Aramzena o valor do bit0 do acumulador no LDR0 ~ LDR7
tmp(12)	 := STA & "100000001"; -- STA @257   Aramzena o valor do bit0 do acumulador no LDR8
tmp(13)	 := STA & "100000010"; -- STA @258   Aramzena o valor do bit0 do acumulador no LDR9
tmp(14)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com o valor 0
tmp(15)	 := STA & "000000000"; -- STA @0   Armazena o valor do acumulador em MEM[0] (constante 0)
tmp(16)	 := LDI & "000000001"; -- LDI $1   Carrega  acumulador com o valor 1
tmp(17)	 := STA & "000000001"; -- STA @1   Armazena o valor do acumulador em MEM[1] (constante 1)
tmp(18)	 := LDI & "000001010"; -- LDI $10   Carrega  acumulador com o valor 10
tmp(19)	 := STA & "000000010"; -- STA @2   Armazena o valor do acumulador em MEM[2] (constante 10)
tmp(20)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com o valor 0
tmp(21)	 := STA & "000000011"; -- STA @3   Armazena o valor do acumulador em MEM[3] (unidade)
tmp(22)	 := STA & "000000100"; -- STA @4   Armazena o valor do acumulador em MEM[4] (dezena)
tmp(23)	 := STA & "000000101"; -- STA @5   Armazena o valor do acumulador em MEM[5] (centena)
tmp(24)	 := STA & "000000110"; -- STA @6   Armazena o valor do acumulador em MEM[6] (unidade de milhar)
tmp(25)	 := STA & "000000111"; -- STA @7   Armazena o valor do acumulador em MEM[7] (dezena de milhar)
tmp(26)	 := STA & "000001000"; -- STA @8   Armazena o valor do acumulador em MEM[8] (centena de milhar)
tmp(27)	 := LDI & "000001001"; -- LDI $9   Carrega acumulador com o valor 9
tmp(28)	 := STA & "000001001"; -- STA @9   Armazena o valor do acumulador em MEM[9] (limite de unidade)
tmp(29)	 := STA & "000001010"; -- STA @10   Armazena o valor do acumulador em MEM[10] (limite de dezena)
tmp(30)	 := STA & "000001011"; -- STA @11   Armazena o valor do acumulador em MEM[11] (limite de centena)
tmp(31)	 := STA & "000001100"; -- STA @12   Armazena o valor do acumulador em MEM[12] (limite de unidade de milhar)
tmp(32)	 := STA & "000001101"; -- STA @13   Armazena o valor do acumulador em MEM[13] (limite de dezena de milhar)
tmp(33)	 := STA & "000001110"; -- STA @14   Armazena o valor do acumulador em MEM[14] (limite de centena de milhar)
tmp(34)	 := LDI & "010000000"; -- LDI $128  
tmp(35)	 := STA & "000010000"; -- STA @16   MEM[16] = Máscara 10000000
tmp(36)	 := LDI & "001000000"; -- LDI $64  
tmp(37)	 := STA & "000010001"; -- STA @17   MEM[17] = Máscara 01000000
tmp(38)	 := LDI & "000100000"; -- LDI $32  
tmp(39)	 := STA & "000010010"; -- STA @18   MEM[18] = Máscara 00100000
tmp(40)	 := LDI & "000010000"; -- LDI $16  
tmp(41)	 := STA & "000010011"; -- STA @19   MEM[19] = Máscara 00010000
tmp(42)	 := LDI & "000001100"; -- LDI $12  
tmp(43)	 := STA & "000010100"; -- STA @20   MEM[20] = Máscara 00001100
tmp(44)	 := LDI & "000001010"; -- LDI $10  
tmp(45)	 := STA & "000010101"; -- STA @21   MEM[21] = Máscara 00001010
tmp(46)	 := LDA & "101100000"; -- LDA @352   Carrega no acumulador o valor de KEY0 ------------ Inicia KEY0
tmp(47)	 := CEQ & "000000000"; -- CEQ @0   Compara com o valor 0
tmp(48)	 := JEQ & "000110010"; -- JEQ @CHECA_KEY1   Pula para leitura de KEY1 se KEY0 não foi pressionado
tmp(49)	 := JSR & "000111010"; -- JSR @ROTINA_INCREMENTO   Se KEY0 foi pressionado, segue para sub-rotina de incremento
tmp(50)	 := LDA & "101100001"; -- LDA @353   Carrega no acumulador o valor de KEY1 ------------ Inicia KEY1
tmp(51)	 := CEQ & "000000000"; -- CEQ @0   Compara com 0
tmp(52)	 := JEQ & "000110110"; -- JEQ @CHECA_KEY_RESET   Se KEY1 não foi pressionado, pula para leitura do RESET
tmp(53)	 := JSR & "001010110"; -- JSR @ROTINA_CONFIGURAÇÃO_LIMITE   Se KEY1 foi pressionado, segue para sub-rotina de configuração de limite
tmp(54)	 := LDA & "101100100"; -- LDA @356   Carrega no acumulador o valor de KEY_RESET ------------ Inicia KEY_RESET
tmp(55)	 := CEQ & "000000001"; -- CEQ @1   Compara com 1
tmp(56)	 := JEQ & "000000000"; -- JEQ @SETUP   Se for igual, vai pro início do programa
tmp(57)	 := JMP & "000101110"; -- JMP @ROTINA_PRINCIPAL   Ao retornar da sub-rotina, volta ao loop principal
tmp(58)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com valor 0 ------------------------------------- ROTINA INCREMENTO (52)
tmp(59)	 := STA & "111111111"; -- STA @511   Limpa leitura de KEY0
tmp(60)	 := LDA & "000001001"; -- LDA @9   Carrega no acumulador o limite das unidades 
tmp(61)	 := CEQ & "000000011"; -- CEQ @3   Compara unidade com seu respectivo limite
tmp(62)	 := JEQ & "001000000"; -- JEQ @VERIFICA_DEZENA   Se for igual, verifica as dezenas
tmp(63)	 := JMP & "001000011"; -- JMP @INCREMENTA_UNIDADE   Se não for igual, segue direto para a parte de incrementa
tmp(64)	 := LDA & "000001010"; -- LDA @10   Carrega no acumulador o limite das dezenas
tmp(65)	 := CEQ & "000000100"; -- CEQ @4   Compara dezena com seu respectivo limite
tmp(66)	 := JEQ & "010101011"; -- JEQ @ROTINA_FIM_PROGRAMA   Se for igual, pula para o fim do programa (houve estouro)
tmp(67)	 := LDA & "000000011"; -- LDA @3   Carrega no acumulador o valor das unidades -------- incrementa unidade
tmp(68)	 := SOMA & "000000001"; -- SOMA @1   Soma um nesse valor
tmp(69)	 := STA & "000000011"; -- STA @3   Atualiza o valor das unidades na memória
tmp(70)	 := STA & "100100000"; -- STA @288   Atualiza o valor do display hexadecimal das unidades
tmp(71)	 := LDA & "000000010"; -- LDA @2   Carrega no acumulador o valor 10
tmp(72)	 := CEQ & "000000011"; -- CEQ @3   Compara unidades com 10
tmp(73)	 := JEQ & "001001011"; -- JEQ @CORRIGE_UNIDADE   Se estourou as unidades, atualiza
tmp(74)	 := RET & "000000000"; -- RET #   Se não estourou, retorna ao loop principal
tmp(75)	 := LDI & "000000000"; -- LDI $0   Houve estouro de unidades => Carrega acumulador com 0
tmp(76)	 := STA & "000000011"; -- STA @3   Grava 0 no contador das unidades
tmp(77)	 := STA & "100100000"; -- STA @288   Grava 0 no display hexadecimal das unidades
tmp(78)	 := LDA & "000000100"; -- LDA @4   Carrega no acumulador o valor das DEZENAS ----------- incrementa dezena
tmp(79)	 := SOMA & "000000001"; -- SOMA @1   Soma um nesse valor
tmp(80)	 := STA & "000000100"; -- STA @4   Atualiza o valor das dezenas na memória
tmp(81)	 := STA & "100100001"; -- STA @289   Atualiza o valor do display hexadecimal das dezenas
tmp(82)	 := LDA & "000000010"; -- LDA @2   Carrega no acumulador o valor 10
tmp(83)	 := CEQ & "000000100"; -- CEQ @4   Compara dezenas com 10
tmp(84)	 := JEQ & "010101011"; -- JEQ @ROTINA_FIM_PROGRAMA   Se estourou as dezenas, estourou o limite => vai para o final do programa
tmp(85)	 := RET & "000000000"; -- RET #   Se não estourou, retorna ao loop principal
tmp(86)	 := LDI & "000000001";
tmp(87)	 := STA & "100000001";
tmp(88)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com 0 ---------------------------- ROTINA CONFIGURAÇÃO DE LIMITE
tmp(89)	 := STA & "111111110"; -- STA @510   Limpa leitura de KEY1
tmp(90)	 := LDA & "101100001"; -- LDA @353   Carrega o valor de KEY1 no acumulador 
tmp(91)	 := CEQ & "000000000"; -- CEQ @0   Compara KEY1 com 0
tmp(92)	 := JEQ & "001011010"; -- JEQ @LE_KEY1_1   Se for igual (não pressionado), volta à leitura de KEY1
tmp(93)	 := LDA & "101000000"; -- LDA @320   Carrega no acumulador o valor de SW07 (considere que vai de 0 a 9)
tmp(94)	 := ANDOP & "000010000";
tmp(95)	 := CEQ & "000010000"; -- CEQ @16   Aplica máscara
tmp(96)	 := JEQ & "001110111";
tmp(97)	 := LDA & "101000000";
tmp(98)	 := ANDOP & "000010001";
tmp(99)	 := CEQ & "000010001";
tmp(100)	 := JEQ & "001110111";
tmp(101)	 := LDA & "101000000";
tmp(102)	 := ANDOP & "000010010";
tmp(103)	 := CEQ & "000010010";
tmp(104)	 := JEQ & "001110111";
tmp(105)	 := LDA & "101000000";
tmp(106)	 := ANDOP & "000010011";
tmp(107)	 := CEQ & "000010011";
tmp(108)	 := JEQ & "001110111";
tmp(109)	 := LDA & "101000000";
tmp(110)	 := ANDOP & "000010100";
tmp(111)	 := CEQ & "000010100";
tmp(112)	 := JEQ & "001110111";
tmp(113)	 := LDA & "101000000";
tmp(114)	 := ANDOP & "000010101";
tmp(115)	 := CEQ & "000010101"; -- CEQ @21   Aplica máscara
tmp(116)	 := JEQ & "001110111";
tmp(117)	 := LDA & "101000000";
tmp(118)	 := JMP & "001111001"; -- JMP @GRAVA_LIMITE_UNIDADE   Limite permitido
tmp(119)	 := LDI & "000001001"; -- LDI $9   Limite não permitido, então passa a ser 9
tmp(120)	 := JMP & "001111001";
tmp(121)	 := STA & "000001001"; -- STA @9   Grava leitura das chaves na memória para limite das unidades
tmp(122)	 := LDI & "000000001"; -- LDI $1   Carrega 1 no acumulador
tmp(123)	 := STA & "100000000"; -- STA @256   Grava em LEDR07 para confirmar primeira configuração
tmp(124)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com 0
tmp(125)	 := STA & "111111110"; -- STA @510   Limpa leitura de KEY1
tmp(126)	 := LDA & "101100001"; -- LDA @353   Carrega o valor de KEY1 no acumulador ----- config. dezenas
tmp(127)	 := CEQ & "000000000"; -- CEQ @0   Compara KEY1 com 0
tmp(128)	 := JEQ & "001111110"; -- JEQ @LE_KEY1_2   Se for igual (não pressionado), volta à leitura de KEY1
tmp(129)	 := LDA & "101000000"; -- LDA @320   Carrega no acumulador o valor de SW07 (considere que vai de 0 a 9)
tmp(130)	 := ANDOP & "000010000";
tmp(131)	 := CEQ & "000010000"; -- CEQ @16   Aplica máscara
tmp(132)	 := JEQ & "010011011";
tmp(133)	 := LDA & "101000000";
tmp(134)	 := ANDOP & "000010001";
tmp(135)	 := CEQ & "000010001";
tmp(136)	 := JEQ & "010011011";
tmp(137)	 := LDA & "101000000";
tmp(138)	 := ANDOP & "000010010";
tmp(139)	 := CEQ & "000010010";
tmp(140)	 := JEQ & "010011011";
tmp(141)	 := LDA & "101000000";
tmp(142)	 := ANDOP & "000010011";
tmp(143)	 := CEQ & "000010011";
tmp(144)	 := JEQ & "010011011";
tmp(145)	 := LDA & "101000000";
tmp(146)	 := ANDOP & "000010100";
tmp(147)	 := CEQ & "000010100";
tmp(148)	 := JEQ & "010011011";
tmp(149)	 := LDA & "101000000";
tmp(150)	 := ANDOP & "000010101";
tmp(151)	 := CEQ & "000010101";
tmp(152)	 := JEQ & "010011011";
tmp(153)	 := LDA & "101000000";
tmp(154)	 := JMP & "010011101";
tmp(155)	 := LDI & "000001001"; -- LDI $9   Limite não permitido, então passa a ser 9
tmp(156)	 := JMP & "010011101";
tmp(157)	 := STA & "000001010"; -- STA @10   Grava leitura das chaves na memória para limite das dezenas
tmp(158)	 := LDI & "000000011"; -- LDI $3   Carrega 3 no acumulador
tmp(159)	 := STA & "100000000"; -- STA @256   Grava em LEDR07 para confirmar segunda configuração
tmp(160)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com 0
tmp(161)	 := STA & "111111110"; -- STA @510   Limpa leitura de KEY1
tmp(162)	 := LDA & "101100001"; -- LDA @353   Carrega o valor de KEY1 no acumulador ----- pressionar para retornar ao loop
tmp(163)	 := CEQ & "000000000"; -- CEQ @0   Compara KEY1 com 0
tmp(164)	 := JEQ & "010100010"; -- JEQ @LE_KEY1_3   Se for igual (não pressionado), volta à leitura de KEY1
tmp(165)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com 0
tmp(166)	 := STA & "100000000"; -- STA @256   Grava nos LEDR07 (apaga os LEDs)
tmp(167)	 := STA & "100000001"; -- STA @257   Apaga LDER8
tmp(168)	 := LDI & "000000000"; -- LDI $0   Carrega acumulador com 0
tmp(169)	 := STA & "111111110"; -- STA @510   Limpa leitura de KEY1
tmp(170)	 := RET & "000000000";
tmp(171)	 := LDI & "000000001"; -- LDI $1   Carrega acumulador com 1 --------------------------- FIM DO PROGRAMA (104)
tmp(172)	 := STA & "100000010"; -- STA @258   Grava valor no LEDR9 (acende o LEDR9)
tmp(173)	 := LDA & "101100100";
tmp(174)	 := CEQ & "000000001";
tmp(175)	 := JEQ & "000000000";
tmp(176)	 := NOP & "000000000";
tmp(177)	 := JMP & "010101101"; -- JMP @LOOP_INFINITO   Fim. Fica preso neste laço até resetar.
